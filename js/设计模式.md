# 设计模式

## 一、单例模式

### 1.1 定义

单例模式（Singleton Pattern）是一种常用的软件设计模式，其核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。

### 1.2 优点

1. **控制实例数量**：单例模式可以控制实例的数量，确保系统中只有一个实例存在，避免了资源浪费。
2. **全局访问点**：单例模式提供了一个全局访问点，使得其他对象可以通过这个访问点来获取唯一的实例，避免了直接创建实例带来的复杂性。
3. **延迟加载**：单例模式支持延迟加载，即在需要时才创建实例，这样可以提高系统的性能和响应速度。

### 1.3 缺点

1. **全局变量**：单例模式将实例作为全局变量，可能会导致代码的耦合度增加，不利于代码的测试和维护。
2. **扩展性差**：单例模式将实例作为全局变量，使得扩展性较差，如果需要修改实例的创建方式，需要修改全局代码。
3. **线程安全问题**：在多线程环境下，单例模式的实现需要考虑线程安全问题，否则可能会导致多个线程同时创建实例。

### 1.4 实现方式
1. **饿汉式**：在类加载时就创建实例，线程安全，但可能会导致资源浪费。
2. **懒汉式**：在需要时才创建实例，延迟加载，但需要考虑线程安全问题。
3. **双重检查锁定**：在懒汉式的基础上，通过双重检查锁定来确保线程安全。
4. **静态内部类**：通过静态内部类来实现懒汉式，线程安全且延迟加载。

### 1.5 应用场景
1. **配置管理**：单例模式可以用于配置管理，确保整个应用程序只有一个配置实例。
2. **数据库连接池**：单例模式可以用于数据库连接池，确保整个应用程序只有一个数据库连接池实例。
3. **日志管理**：单例模式可以用于日志管理，确保整个应用程序只有一个日志实例。
4. **缓存管理**：单例模式可以用于缓存管理，确保整个应用程序只有一个缓存实例。

### 1.6 代码示例
```javascript
// 饿汉式
class Singleton {
  static instance = new Singleton();
  constructor() {}
  static getInstance() {
    return this.instance;
  }
}

// 懒汉式
class Singleton {
  constructor() {}
  static instance = null;
  static getInstance() {
    if (!this.instance) {
      this.instance = new Singleton();
    }
    return this.instance;
  }
}

// 双重检查锁定
class Singleton {
  constructor() {}
  static instance = null;
  static getInstance() {
    if (!this.instance) {
      synchronized(Singleton.class) {
        if (!this.instance) {
          this.instance = new Singleton();
        }
      }
    }
    return this.instance;
  }
}

// 静态内部类
class Singleton {
  constructor() {}
  static getInstance() {
    return SingletonHolder.instance;
  }
  static class SingletonHolder {
    static instance = new Singleton();
  }
}
```

## 二、工厂模式

### 2.1 定义

工厂模式（Factory Pattern）是一种创建型设计模式，其核心思想是通过一个工厂类来创建对象，而不是直接使用 `new` 关键字来创建对象。工厂模式可以封装对象的创建过程，使得代码更加灵活和可维护。

### 2.2 优点
1. **封装对象创建过程**：工厂模式将对象的创建过程封装在一个工厂类中，使得代码更加清晰和易于维护。
2. **代码解耦**：工厂模式将对象的创建过程与使用过程解耦，使得代码更加灵活和可扩展。
3. **支持延迟加载**：工厂模式支持延迟加载，可以在需要时才创建对象，提高系统的性能和响应速度。

### 2.3 缺点
1. **增加代码复杂度**：工厂模式需要增加一个工厂类，可能会增加代码的复杂度。
2. **扩展性差**：如果需要增加新的对象类型，需要修改工厂类，可能会影响代码的可维护性。

### 2.4 实现方式
1. **简单工厂模式**：通过一个工厂类来创建对象，工厂类根据传入的参数来决定创建哪个对象。
2. **工厂方法模式**：通过定义一个工厂接口，然后由子类来实现具体的工厂方法，创建对象。
3. **抽象工厂模式**：通过定义一个工厂接口，然后由子类来实现具体的工厂方法，创建对象，并且可以创建一组相关的对象。

### 2.5 应用场景
1. **对象创建过程复杂**：当对象的创建过程比较复杂，需要封装时，可以使用工厂模式。
2. **需要延迟加载**：当需要延迟加载对象时，可以使用工厂模式。
3. **需要创建一组相关的对象**：当需要创建一组相关的对象时，可以使用工厂模式。

### 2.6 代码示例
```javascript
// 简单工厂模式
class Product {
  constructor() {}
  method() {}
}

class ConcreteProductA extends Product {
  constructor() {
    super();
  }
  method() {
    console.log('ConcreteProductA method');
  }
}

class ConcreteProductB extends Product {
  constructor() {
    super();
  }
  method() {
    console.log('ConcreteProductB method');
  }
}
class SimpleFactory {
  static createProduct(type) {
    switch (type) {
      case 'A':
        return new ConcreteProductA();
      case 'B':
        return new ConcreteProductB();
      default:
        return null;
    }
  }
}

// 工厂方法模式
class Product {
  constructor() {}
  method() {}
}

class ConcreteProductA extends Product {
  constructor() {
    super();
  }
  method() {
    console.log('ConcreteProductA method');
  }
}

class ConcreteProductB extends Product {
  constructor() {
    super();
  }
  method() {
    console.log('ConcreteProductB method');
  }
}

class Factory {
  createProduct() {
    return new Product();
  }
}

class ConcreteFactoryA extends Factory {
  createProduct() {
    return new ConcreteProductA();
  }
}

class ConcreteFactoryB extends Factory {
  createProduct() {
    return new ConcreteProductB();
}
}

// 抽象工厂模式
class AbstractFactory {
  createProductA() {}
  createProductB() {}
}

class ConcreteFactoryA extends AbstractFactory {
  createProductA() {
    return new ConcreteProductA();
  }
  createProductB() {
    return new ConcreteProductB();
  }
}

class ConcreteFactoryB extends AbstractFactory {
  createProductA() {
    return new ConcreteProductC();
  }
  createProductB() {
    return new ConcreteProductD();
  }
}
```
