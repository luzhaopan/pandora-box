在正常的数学逻辑思维中，0.1+0.2=0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2 !== 0.3，在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为false。

原因很简单，因为0.1存储的值比实际值大了一点，0.2也是大了一点（差值比0.1大一倍），两个相加就大很多了，多出来的就是那个尾巴。为什么0.1不能够被准确存储呢？因为计算机都是二进制的，在十进制能表示的数不一定能被二进制精确表示，就好像在十进制里面无法准确表示1/3一样，而在三进制里面0.1便表示1/3了。在二进制里面能够被精确表示都必须得是二的倍数的组合，如二进制的0.1表示十进制的0.5，0.11便表示0.75（ = 0.5 + 0.25），0.111表示0.875（ = 0.5 + 0.25 + 0.125），假设现在要存储0.625那么能够被精确表示为二进制的0.101，如果要表示0.626呢？那么应该是通过后面的小数位相加拼凑，让其尽可能逼近0.626. 这个时候就不是精确表示了，这个事情就是编译器的工作。

那么应该怎样来解决0.1+0.2等于0.3呢? 最好的方法是设置一个误差范围值，通常称为”机器精度“，而对于Javascript来说，这个值通常是2^-52,而在ES6中，已经为我们提供了这样一个属性：

Number.EPSILON，而这个值正等于2^-52（2的52次方分之一）。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true。

```js
function number(a, b) {
    return Math.abs(a - b) < Number.EPSILON;
}
var a = 0.1 + 0.2;
var b = 0.3;
console.log(a);
console.log(b);
console.log(number(a, b));
```

但是这里要考虑兼容性的问题了，在chrome中支持这个属性，但是IE并不支持(笔者的版本是IE10不兼容)，所以我们还要解决IE的不兼容问题。

```js
Number.EPSILON=(function(){   //解决兼容性问题
    return Number.EPSILON?Number.EPSILON:Math.pow(2,-52);
})();

function number(a, b) {
    return Math.abs(a - b) < Number.EPSILON;
}
var a = 0.1 + 0.2;
var b = 0.3;
console.log(a);
console.log(b);
console.log(number(a, b));
```