# 浏览器缓存的优缺点

优点：

1. 减少了冗余的数据传输，节省了网费
2. 减少了服务器的负担，大大提升了网站的性能
3. 加快了客户端加载网页的速度

缺点：

1. 缓存更新问题
2. 缓存数据管理问题

# http缓存

1. 客户端向服务器发起请求时，会根据HTTP响应头的字段加载缓存的资源。
2. http 缓存从第二次开始。第一次请求从服务器加载所有资源，第二次请求浏览器根据响应头的字段加载缓存资源。
3. http 缓存分为 强缓存 与 协商缓存。无论是命中哪个缓存资源都是从客户端本地加载，不同的是协商缓存会向服务器发起请求，强缓存不会向服务器发起请求。

# 浏览器缓存：
1. 浏览器缓存分为：内存缓存(memory-cache)、硬盘缓存(disk-cache)

打开浏览器控制台，选择Network（网络），再刷新浏览器，我们就能看到请求资源详情：

![](./img/2023-05-22-15-57-43.png)

一般频繁操作的文件都缓存在内存中，加载十分迅速。操作不频繁的文件就会缓存在硬盘中，加载速度也会较慢。
到底什么文件会缓存在内存中、什么会缓存在硬盘中，我们并不需要关心，让浏览器自己决定就行（其实也不清楚）。


# 强缓存（Cache-Control）：
不会进行http请求，读取的是内存中的资源，直到缓存失效

涉及到的状态码：

- 200（from memory cache）
- 200（from disk cache）
  
涉及到的http header： 

- cache-control
- expires

强制缓存在客户端本地，请求直接从本地缓存中加载，不去请求服务器，返回的状态码是 200。强缓存需要 Cache-Control 字段， Cache-Control 是 HTTP 响应头中的字段。你可能在网上会看到有人会说还有 expires，pragma ，但都是 http1.0 的产物，现在应用最广泛的是 http1.1。所以我们减少一点学习压力，熟悉 Cache-Control 字段即可。
当我们向服务器请求资源时，服务器认为需要被缓存的资源比如（css，js文件 、图片），这些资源在响应头中都会默认携带 Cache-Control: public, max-age=0 。public, max-age=0 是默认值（相当于没有对资源缓存进行处理）。

## Cache-Control 属性值：
强缓存依赖 Cache-Control 字段，所以我们需要熟悉该字段的属性值，多个属性值用逗号隔开。
1. public           这些资源可以被任意对象缓存（如：客户端，代理服务器，等等）
2. private          这些资源只能在客户端缓存
3. max-age=xx       设置资源缓存的最大时间，超过时间表示缓存过期，请求会发到服务器（单位：秒）
4. no-cache         加载缓存资源前，强制发送请求到服务器进行“协商缓存”
5. no-store         不被做任何缓存
   

# 协商缓存（Etag）：

涉及到的状态码：

- 304 not modified
- 200 ok

涉及到的请求头

- etag / if-none-match
- last-modified / if-modified-since

请求的资源通过资源标识与服务器协商比对，协商成功，服务器返回304状态码，浏览器从本地加载。
协商缓存需要用到 Etag 字段 与 if-none-match，Etag 是 HTTP 响应头中的字段，Etag 的值是根据资源内容编码生成的一段字符串（资源标识），内容不同就会生成不同的Etag。
你可能在网上看到还有 Last-modified ，了解即可。

再次发起请求时，请求头会带有 if-none-match 字段，值为上一次响应的 Etag（没有则不会携带）。服务器会将请求的资源生成资源标识与发送过来的值进行比对，如果比对成功则返回 304 状态码，浏览器从本地加载该资源。
如果协商失败服务器会返回新的资源+新的Etag（资源标识）。

## 为什么要有Etag
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？
HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间。
   
Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

### etag两种类型：

- 强etag:

不论实体发生多么细微的变化都会改变其值

强ETag表示形式："22FAA065-2664-4197-9C5E-C92EA03D0A16"。

- 弱etag:

弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变产 生差异时才会改变 ETag 。这时，会在字段值最开始处附加 W/。

弱ETag表现形式：W/"22FAA065-2664-4197-9C5E-C92EA03D0A16"。


## ETag和Last-Modified的作用和用法，他们的区别：

协商缓存靠Etag和Last-Modified控制的

Last-Modified是通过最后一次修改时间来判断资源是否发生改变

Etag是用 hash 内容对比判断是否资源发生改变

1. Etag要优于Last-Modified。
   Last-Modified 以秒为单位，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，
   但是Etag值内容是唯一的，通过对比就很快知道资源是否发送改变, 每次都会改变确保了精度；

2. 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；
   
3. 在优先级上，服务器校验优先考虑Etag。

# 缓存过程

![](./img/2023-05-22-16-10-38.png)

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
   
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
   
3. 客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，If-None-Match的值设为false，返回304，客户端继续使用本地缓存，不解析服务器端发回来的数据；如果不一致则有改动，If-None-Match的值设为true，返回状态为200，客户端重新解析服务器端返回的数据；
   
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存；

## 解决方案

1. 在地址栏中输入网址后按回车或者点击转到按钮

浏览器以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存即使用强缓存，从而减少了对服务器的请求，Expires、max-age标志只对这种方式有效。

2. 点击刷新按钮或者按F5

浏览器会在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存即跳过强缓存的判断，直接进行协商缓存的判断，会带上If-Modifed-Since，If-None-Match，Last-Modified、ETag在这种方式发挥作用，这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200。

3. 用户按Ctrl+F5（强制刷新）

强制刷新，完全不使用缓存。

![](./img/image2024-07-02-17-40-08.png)


# 强缓存的应用

强缓存是前端性能优化最有力的工具，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度，通常是为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户只会在第一次访问网站时加载静态资源，其他时间只要缓存没有失效并且用户没有强制刷新的条件下都会从缓存中加载。

然而这种缓存配置方式会带来一个问题，就是当资源更新时，客户端由于有缓存不会向服务器请求最新的资源，这个问题已有解决方案：

通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。

但要实现有更新的文件才需要浏览器重新加载，因此必须让url的修改与文件内容相关联，利用数据摘要算法对文件求摘要信息，摘要信息与文件内容一一对应，这一点许多前端构建工具都做到了，如webpack。

# 浏览器默认缓存使开发环境下常因为资源没有及时更新而看不到效果

解决方法：

1、ctrl+F5

2、浏览器隐私模式开发

3、chrome开发者工具里将Disable cache选项打勾，阻止缓存

4、在开发阶段，给资源加上一个动态的参数，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非是在动态页面比如jsp里开发就可以用服务器变量来解决，或者用前端构建工具来处理这个参数修改的问题。

5、如果资源引用的页面被嵌入到了一个iframe里面，可以在iframe的区域右键重新加载该页面

6、如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数

7、动态设置iframe的src时，有可能因为缓存问题导致看不到最新效果，在src后面添加随机数即可

8、通过前端开发工具grunt gulp等的插件来启动一个静态服务器，则在这个服务器下所有资源返回的response header中，Cache-Control始终被设置为不缓存。

# 发布问题

发布问题：若页面和它引用的资源路径同时更新了，不管是先部署页面还是先部署资源都会带来各种问题，这是由于资源是覆盖式发布的，即用待发布资源覆盖已发布资源。

解决办法就是实现非覆盖式发布：把有修改的资源文件作为一个新的文件发布，不对已有的资源文件进行覆盖，这样用户还可以请求旧的资源文件，不至于发生页面错乱的问题，这样先部署静态资源，再覆盖式部署页面，等到用户访问新页面的时候，新的资源文件也已发布，就可以正确请求，即可解决问题。