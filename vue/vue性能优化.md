![](./img/2024-01-22-21-49-32.png)

# 1.合理使用key

key 作用：
- 提高渲染效率 当 Vue 在进行虚拟 DOM 的 diff 算法比较新旧节点时，如果节点具有相同的 key，则 Vue
会认为它们是相同的节点，不会进行重新渲染，从而提高渲染效率。
- 保持组件状态 在使用 v-for 指令渲染列表时，每个列表项都应该拥有唯一的 key，这样可以在列表项顺序改变时，Vue
可以准确地判断哪些列表项是新添加的，哪些列表项是已存在但位置改变的，哪些列表项是被删除的，从而保持组件状态的正确性。

# 2.数据层级不宜过深，合理设置响应式数据



# 3.通过object.freeze()冻结属性

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```sh
export default {
  data: () => ({
    users: {}
  }),

  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
}
```


# 4.使用数据时候缓存结果，不频繁取值


# 5.合理选取v-show和v-if


# 6.控制组件粒度，vue采用组件级更新

Vue.js的设计理念之一就是通过将应用程序分为多个可重复使用的组件来构建界面。每个组件都有自己的状态（data）、模板（template）以及行为（methods）等属性。

在Vue中，当数据发生变化时，只会影响到相关联的组件进行局部更新，而不需要对整个页面进行全量更新。这种机制被称为"组件级更新"或者"虚拟DOM diff算法"。

# 7.采用函数式组件
函数式组件开销低

函数式组件是无状态，它无法实例化，没有任何的生命周期和方法。创建函数式组件也很简单，只需要在模板添加 functional 声明即可。一般适合只依赖于外部数据的变化而变化的组件，因其轻量，渲染性能也会有所提高。

# 8.采用异步组件

借助webpack的分包能力


# 9.合理使用keep-alive缓存组件


# 10.分页、虚拟滚动、时间分片


# 7.不要将所有的数据都放到 data 中

data 中的数据都会增加 getter 和 setter，又会收集 watcher，这样还占内存。不需要响应式的数据我们可以定义在实例上

vue3 不要定义成响应式数据